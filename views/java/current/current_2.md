# 安全性、活跃性以及性能问题

安全性问题：
程序按照我们期望的执行，不要让我们感到意外。
其实只有一种情况需要：
存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据。
数据竞争：
当多个线程调用时候就会发生数据竞争。
竞态条件：
指的是程序的执行结果依赖线程执行的顺序。
```
if (状态变量 满足 执行条件) {
  执行操作
}
```
解决方案——互斥：
CPU 提供了相关的互斥指令，操作系统、编程语言也会提供相关的 API——锁。

活跃性问题：
除了死锁外，还有两种情况，分别是“活锁”和“饥饿”。
所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况
例子：
路人甲从左手边出门，路人乙从右手边进门，两人为了不相撞，互相谦让，路人甲让路走右手边，路人乙也让路走左手边，结果是两人又相撞了
三种解决方案：
有三种方案：
1、是保证资源充足
2、是公平地分配资源
3、就是避免持有锁的线程长时间执行
这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。


性能问题：
锁”的过度使用可能导致串行化的范围过大
阿姆达尔（Amdahl）定律：
![image.png](https://cdn.nlark.com/yuque/0/2019/png/257847/1576406796552-76d3c579-f505-49e1-a839-6a880ee39aa8.png#align=left&display=inline&height=91&name=image.png&originHeight=91&originWidth=177&size=1920&status=done&style=none&width=177)
公式里的 n 可以理解为 CPU 的核数，p 可以理解为并行百分比，那（1-p）就是串行百分比了，也就是我们假设的 5%。我们再假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是 20。也就是说**，如果我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能**。
**Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。**
**性能指标：**
吞吐量：指的是单位时间内能处理的请求数量。
延迟：指的是从发出请求到收到响应的时间。
并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。
**解决：**
第一，使用无锁的算法和数据结构
在这方面有很多相关的技术，例如线程本地存储 (Thread Local Storage, TLS)、写入时复制 (Copy-on-write)、乐观锁等；Java 并发包里面的原子类也是一种无锁的数据结构；Disruptor 则是一个无锁的内存队列，性能都非常好……
第二，减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。这个方案具体的实现技术也有很多，例如使用细粒度的锁，一个典型的例子就是 Java 并发包里的 ConcurrentHashMap，它使用了所谓分段锁的技术（这个技术后面我们会详细介绍）；还可以使用读写锁，也就是读是无锁的，只有写的时候才会互斥。


